<!DOCTYPE html>
<!--
PROMPT GENERATOR - Configured for Quick-Vendz/promptr repository

This prompt generator fetches tag files directly from the GitHub repository.
Tag files (kage, pony, sdxl) are loaded from:
https://raw.githubusercontent.com/Quick-Vendz/promptr/main/

Tag file format:
# Category Name
Simple Tag
Another Tag

# Prefix (categories with "prefix" in name become prefix tags)
Style Name|prompt,values

# Negative Prompts (categories with "negative" in name become negative tags)  
Issue Name|negative,prompt,values
-->
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CSP temporarily disabled for debugging - will re-enable with proper configuration -->
    <!-- <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; 
                   script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://unpkg.com; 
                   style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com; 
                   connect-src 'self' https://raw.githubusercontent.com; 
                   img-src 'self' data:; 
                   font-src 'self' data:;"> -->
    <title>Prompt Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- CDN scripts restored to original configuration for compatibility -->
    <style>
        [x-cloak] { display: none !important; }
        
        /* Dark mode scrollbars */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        
        ::-webkit-scrollbar-thumb {
            background: #374151; /* gray-700 */
            border-radius: 6px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563; /* gray-600 */
        }
        
        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: #374151 #1f2937;
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen text-gray-100">
    <div x-data="promptGenerator()" x-cloak class="flex h-screen">
        <!-- Left Panel - Categories and Tags -->
        <div class="w-1/2 bg-gray-800 border-r border-gray-700 overflow-y-auto h-screen">
            <div class="p-6 border-b border-gray-700">
                <div class="flex items-center justify-between mb-4">
                    <div>
                        <h1 class="text-2xl font-bold text-gray-100">Prompt Categories</h1>
                        <p class="text-gray-400 mt-1">Click tags to add them to your prompt</p>
                    </div>
                    <div class="flex flex-col items-end gap-2">
                        <label class="text-sm text-gray-400">Tag File:</label>
                        <div class="flex gap-2 items-center">
                            <button 
                                x-show="availableFiles.find(f => f.file === selectedFile && f.isLocal === true && !f.isBuiltIn)"
                                @click="removeLocalFile(selectedFile)"
                                class="bg-red-600 text-white px-3 py-1 text-sm rounded hover:bg-red-700 transition-colors"
                                title="Remove this local file"
                            >
                                Remove
                            </button>
                            <select 
                                x-model="selectedFile" 
                                @change="loadSelectedFile()"
                                class="bg-gray-700 text-gray-100 border border-gray-600 rounded px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 flex-1"
                            >
                                <template x-for="fileInfo in availableFiles" :key="fileInfo.file">
                                    <option :value="fileInfo.file" x-text="fileInfo.isLocal ? '📁 ' + fileInfo.name : fileInfo.name"></option>
                                </template>
                            </select>
                            <button 
                                x-show="availableFiles.find(f => f.file === selectedFile && f.isLocal === true && !f.isBuiltIn)"
                                @click="refreshLocalFile()"
                                class="bg-green-600 text-white px-3 py-1 text-sm rounded hover:bg-green-700 transition-colors"
                                :title="`Refresh/replace '${selectedFile}' with updated version (must select same filename)`"
                            >
                                Refresh
                            </button>
                            <button 
                                @click="$refs.fileInput.click()"
                                class="bg-blue-600 text-white px-3 py-1 text-sm rounded hover:bg-blue-700 transition-colors"
                                title="Load custom tag file"
                            >
                                Browse
                            </button>
                        </div>
                        <input 
                            x-ref="fileInput"
                            type="file" 
                            accept=".txt,.csv"
                            @change="loadCustomFile($event)"
                            class="hidden"
                        />
                    </div>
                </div>
                
                <!-- How to Use Section -->
                <div class="bg-blue-900 border border-blue-700 rounded-lg p-4 mb-4 mt-10" x-show="selectedFile === 'tutorial'">
                    <h3 class="text-lg font-semibold text-blue-200 mb-3">🚀 Quick Start Guide</h3>
                    <div class="space-y-2 text-sm text-blue-100">
                        <div class="flex items-start space-x-2">
                            <span class="bg-blue-700 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold mt-0.5">1</span>
                            <div>
                                <strong>Select a tag collection:</strong> Use the dropdown above to choose a default tag collection
                            </div>
                        </div>
                        <div class="flex items-start space-x-2">
                            <span class="bg-blue-700 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold mt-0.5">2</span>
                            <div>
                                <strong>Browse categories:</strong> Expand sections below and click tags to add them to your prompt
                            </div>
                        </div>
                        <div class="flex items-start space-x-2">
                            <span class="bg-blue-700 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold mt-0.5">3</span>
                            <div>
                                <strong>Build your prompt:</strong> Selected tags appear on the right panel for easy copying
                            </div>
                        </div>
                        <div class="flex items-start space-x-2">
                            <span class="bg-blue-700 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold mt-0.5">4</span>
                            <div>
                                <strong>Get help:</strong> Click any tutorial tag below for detailed information on the right
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="p-6 space-y-4">
                <!-- Tutorial Content (Static HTML) -->
                <div x-show="selectedFile === 'tutorial'" class="border border-blue-600 rounded-lg overflow-hidden bg-blue-900">
                    <!-- Accordion Header -->
                    <button 
                        @click="toggleCategory('📄 Creating Tag Files & Resources')"
                        class="w-full px-4 py-3 text-left bg-blue-700 hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                    >
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <h3 class="font-semibold text-blue-100">📄 Creating Tag Files & Resources</h3>
                            </div>
                            <svg 
                                class="w-5 h-5 text-blue-300 transform transition-transform duration-200"
                                :class="openCategories.includes('📄 Creating Tag Files & Resources') ? 'rotate-180' : ''"
                                fill="none" 
                                stroke="currentColor" 
                                viewBox="0 0 24 24"
                            >
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </button>
                    
                    <!-- Accordion Content -->
                    <div 
                        class="overflow-hidden transition-all duration-300 ease-in-out bg-blue-800"
                        :style="openCategories.includes('📄 Creating Tag Files & Resources') ? 'max-height: 500px;' : 'max-height: 0px;'"
                    >
                        <div class="p-4">
                            <div class="flex flex-wrap gap-2">
                                <button
                                    @click="showTutorialInfo()"
                                    class="px-3 py-1 text-sm rounded-full border bg-green-700 text-green-100 border-green-500 hover:bg-green-600 cursor-pointer transition-all duration-200 hover:shadow-md"
                                >
                                    📝 Complete Guide: Creating & Using Tag Files
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Regular Categories (Dynamic) -->
                <template x-for="category in categories" :key="category.name">
                    <div 
                        class="border rounded-lg overflow-hidden bg-gray-750"
                        :class="category.type === 'prefix' ? 'border-purple-500' : 
                               category.type === 'negative' ? 'border-orange-500' : 
                               'border-gray-600'"
                    >
                        <!-- Accordion Header -->
                        <button 
                            @click="toggleCategory(category.name)"
                            class="w-full px-4 py-3 text-left bg-gray-700 hover:bg-gray-600 focus:outline-none transition-colors"
                        >
                            <div class="flex items-center justify-between">
                                <div class="flex items-center space-x-2">
                                    <h3 
                                        class="font-semibold" 
                                        :class="category.type === 'prefix' ? 'text-purple-300' : 
                                               category.type === 'negative' ? 'text-orange-300' : 
                                               'text-gray-100'"
                                        x-text="category.name"
                                    ></h3>
                                    <span 
                                        x-show="getCategoryCount(category) > 0"
                                        class="px-2 py-1 text-xs rounded-full font-semibold"
                                        :class="category.type === 'prefix' ? 'bg-purple-500 text-white' : 
                                               category.type === 'negative' ? 'bg-orange-500 text-white' : 
                                               'bg-blue-500 text-white'"
                                        x-text="getCategoryCount(category)"
                                    ></span>
                                </div>
                                <svg 
                                    class="w-5 h-5 text-gray-400 transform transition-transform duration-200"
                                    :class="openCategories.includes(category.name) ? 'rotate-180' : ''"
                                    fill="none" 
                                    stroke="currentColor" 
                                    viewBox="0 0 24 24"
                                >
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </div>
                        </button>
                        
                        <!-- Accordion Content with smooth height transition -->
                        <div 
                            class="overflow-hidden transition-all duration-300 ease-in-out bg-gray-800"
                            :style="openCategories.includes(category.name) ? 'max-height: 500px;' : 'max-height: 0px;'"
                        >
                            <div class="p-4" x-show="category.tags && category.tags.length > 0">
                                <div class="flex flex-wrap gap-2">
                                    <template x-for="(tag, index) in category.tags" :key="`${category.name}-${index}-${tag.display || tag}`">
                                        <button
                                            @click="addRemoveTag(tag)"
                                            class="px-3 py-1 text-sm rounded-full border transition-all duration-200 hover:shadow-md"
                                            :class="getTagClass(tag)"
                                            x-text="tag.display || tag"
                                        ></button>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Right Panel - Selected Tags and Prompt -->
        <div class="w-1/2 bg-gray-900 flex flex-col h-screen overflow-y-auto">
            <!-- Tutorial Info Panel (Static HTML) -->
            <div class="bg-gray-800 border-b border-gray-700 p-6" x-show="showInfoPanel">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-blue-300">📖 Tutorial Info</h2>
                    <button 
                        @click="showInfoPanel = false"
                        class="px-3 py-1 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm"
                    >
                        Close
                    </button>
                </div>
                
                <div class="space-y-4 text-sm text-gray-100">
                    <div>
                        <h3 class="font-semibold text-blue-300 mb-2">📝 Complete Guide: Creating & Using Tag Files</h3>
                        <div class="bg-gray-700 rounded-lg p-4">
                            <div class="text-gray-200 space-y-4">
                                <div>
                                    <p class="font-semibold text-blue-200">🎯 Tag File Format:</p>
                                    <pre class="text-sm mt-2 whitespace-pre-wrap bg-gray-800 p-3 rounded border text-green-300">
# Basic Category (standard blue tags - file order preserved)
blonde hair
brown hair
tag_example|multiple, values, here

# Style Prefix [a-z] (purple tags - sorted alphabetically)
Art Style|oil painting, detailed, masterpiece
Photo Style|photorealistic, professional photography
simple_style

# Negative Issues (orange tags - file order preserved)
Quality Problems|blurry, out of focus, low quality
anatomical_issue
Bad Anatomy|deformed, distorted, malformed</pre>
                                    <p class="text-sm text-yellow-300 mt-2">💡 Visual Guide: <span class="border border-gray-400 px-2 py-1 rounded">Simple tags have solid borders</span> while <span class="border-2 border-dashed border-gray-400 px-2 py-1 rounded">multi-value tags have dashed borders</span></p>
                                    <p class="text-sm text-cyan-300 mt-2">🎨 Category Colors: Standard = Blue, Prefix = Purple, Negative = Orange</p>
                                    <p class="text-sm text-green-300 mt-2">📝 Sorting: Add [a-z] to category name for alphabetical sorting, otherwise tags keep file order</p>
                                </div>
                                
                                <div>
                                    <p class="font-semibold text-blue-200">💾 How to Create & Load:</p>
                                    <ol class="mt-2 space-y-1 text-gray-300 list-decimal list-inside">
                                        <li>Create a .txt file using the format above</li>
                                        <li>Save your file with any name (e.g., 'my_tags.txt')</li>
                                        <li>Click the Browse button and select your file</li>
                                        <li>Simple tags (solid border) add one value to your prompt</li>
                                        <li>Multi-value tags (dashed border) add multiple comma-separated values</li>
                                        <li>Categories with 'prefix' in the name become purple tags</li>
                                        <li>Categories with 'negative' in the name become orange tags</li>
                                        <li>Add [a-z] to category name for alphabetical sorting</li>
                                        <li>Categories without [a-z] keep the order from your file</li>
                                    </ol>
                                </div>
                                
                                <div>
                                    <p class="font-semibold text-blue-200">📚 Available Collections:</p>
                                    <ul class="mt-2 space-y-1 text-gray-300 list-disc list-inside">
                                        <li>Tag Types Example - demonstrates all features</li>
                                    </ul>
                                </div>
                                
                                <div class="mt-4">
                                    <a href="https://github.com/Quick-Vendz/promptr/tree/main/tags" target="_blank" 
                                       class="inline-block bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors">
                                        📥 Download Ready-Made Collections →
                                    </a>
                                </div>
                                
                                <p class="text-blue-200 text-sm">Select any collection from the dropdown above to start immediately!</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

                        <!-- Generated Prompt Section -->
            <div class="flex-1 p-6" x-show="selectedFile !== 'tutorial'">
                <div class="flex items-center justify-between mb-4 mt-4">
                    <h2 class="text-xl font-semibold text-gray-100">Generated Prompt</h2>
                    <div class="flex items-center gap-2">
                        <button 
                            @click="clearAllSelections()"
                            class="flex items-center px-3 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 text-sm"
                            x-show="selectedTags.length > 0 || selectedPrefixes.length > 0 || selectedNegatives.length > 0"
                        >
                            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                            </svg>
                            Clear All
                        </button>
                        <button 
                            @click="copyPrompt()"
                            class="flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                            x-show="generatePrompt().length > 0"
                        >
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                            </svg>
                            Copy Prompt
                        </button>
                    </div>
                </div>
                
                <div class="bg-gray-800 border border-gray-600 rounded-lg p-4 min-h-[150px] mb-4">
                    <div 
                        class="whitespace-pre-wrap leading-relaxed" 
                        x-html="generatePromptHTML() || '<span class=&quot;text-gray-400&quot;>Your generated prompt will appear here...</span>'"
                    ></div>
                </div>
                
                <!-- Copy Feedback -->
                <div 
                    x-show="copyFeedback"
                    x-transition:enter="transition ease-out duration-300"
                    x-transition:enter-start="opacity-0 transform translate-y-2"
                    x-transition:enter-end="opacity-100 transform translate-y-0"
                    x-transition:leave="transition ease-in duration-200"
                    x-transition:leave-start="opacity-100 transform translate-y-0"
                    x-transition:leave-end="opacity-0 transform translate-y-2"
                    class="mb-4 p-3 bg-green-900 text-green-200 rounded-lg text-sm"
                >
                    ✓ Prompt copied to clipboard!
                </div>

                <!-- Negative Prompt Section -->
                <div x-show="generateNegativePrompt().length > 0" class="mb-6 mt-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-semibold text-red-300">Negative Prompt</h2>
                        <button 
                            @click="copyNegativePrompt()"
                            class="flex items-center px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-red-700 transition-colors focus:outline-none focus:ring-2 focus:ring-red-500 text-sm"
                        >
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                            </svg>
                            Copy Negative
                        </button>
                    </div>
                    
                    <div class="bg-gray-800 border border-orange-600 rounded-lg p-4 min-h-[100px]">
                        <pre class="whitespace-pre-wrap text-orange-200 leading-relaxed" x-text="generateNegativePrompt()"></pre>
                    </div>
                    
                    <!-- Negative Copy Feedback -->
                    <div 
                        x-show="negativeCopyFeedback"
                        x-transition:enter="transition ease-out duration-300"
                        x-transition:enter-start="opacity-0 transform translate-y-2"
                        x-transition:enter-end="opacity-100 transform translate-y-0"
                        x-transition:leave="transition ease-in duration-200"
                        x-transition:leave-start="opacity-100 transform translate-y-0"
                        x-transition:leave-end="opacity-0 transform translate-y-2"
                        class="mt-4 p-3 bg-green-900 text-green-200 rounded-lg text-sm"
                    >
                        ✓ Negative prompt copied to clipboard!
                    </div>
                </div>
            </div>
            
            <!-- Tutorial Welcome Section -->
            <div class="flex-1 p-6 flex items-center justify-center" x-show="selectedFile === 'tutorial' && !showInfoPanel">
                <!-- <div class="text-center space-y-4">
                    <div class="text-6xl">📚</div>
                    <h2 class="text-2xl font-semibold text-gray-100">Welcome to the Guide!</h2>
                    <p class="text-gray-400 max-w-md">
                        Click any guide section on the left to see detailed information and helpful resources.
                    </p>
                    <div class="bg-blue-900 border border-blue-700 rounded-lg p-4 text-left max-w-md">
                        <h3 class="text-blue-200 font-medium mb-2">💡 Quick Navigation:</h3>
                        <ul class="text-blue-100 text-sm space-y-1">
                            <li>• Start with "� Quick Start Guide" for basics</li>
                            <li>• Check "📄 Tag File Format" to create your own files</li>
                            <li>• Visit "🔗 Example Files & Links" for templates</li>
                            <li>• Use "🐛 Report Issues & Suggestions" to help improve this tool</li>
                        </ul>
                    </div>
                </div> -->
            </div>
            
            <!-- Prefix Tags Section -->
            <div class="bg-gray-800 border-b border-gray-700 p-6" x-show="selectedPrefixes.length > 0 && selectedFile !== 'tutorial'">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-purple-300">Prefix Tags</h2>
                    <button 
                        @click="clearAllPrefixes()"
                        class="text-sm text-red-400 hover:text-red-300 transition-colors"
                    >
                        Clear All
                    </button>
                </div>
                
                <div class="flex flex-wrap gap-2">
                    <template x-for="(tag, index) in selectedPrefixes" :key="`prefix-${index}-${tag.display || tag}`">
                        <span 
                            class="inline-flex items-center text-sm text-white rounded transition-colors"
                            :class="getSelectedTagClass(tag)"
                        >
                            <span 
                                class="px-3 py-1"
                                x-text="tag.display || tag"
                            ></span>
                            <button 
                                @click="removeTag(tag)"
                                class="pr-3 py-1"
                                :class="getButtonTextColor(tag)"
                            >
                                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                        </span>
                    </template>
                </div>
            </div>

            <!-- Selected Tags Section -->
            <div class="bg-gray-800 border-b border-gray-700 p-6" x-show="selectedFile !== 'tutorial'">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-semibold text-gray-100">Selected Tags</h2>
                    <button 
                        @click="clearAllTags()"
                        class="text-sm text-red-400 hover:text-red-300 transition-colors"
                        x-show="selectedTags.length > 0"
                    >
                        Clear All
                    </button>
                </div>
                
                <div class="flex flex-wrap gap-2">
                    <template x-for="(tag, index) in selectedTags" :key="`normal-${index}-${tag.display || tag}`">
                        <span 
                            class="inline-flex items-center text-sm text-white rounded transition-colors"
                            :class="getSelectedTagClass(tag)"
                        >
                            <span 
                                @click="toggleTagStrength(tag)"
                                class="cursor-pointer hover:opacity-80 px-3 py-1"
                                x-text="(tagStrengths[tag.value || tag] === 1 ? '(' + (tag.display || tag) + ')' : (tag.display || tag))"
                            ></span>
                            <button 
                                @click="removeTag(tag)"
                                class="pr-3 py-1"
                                :class="getButtonTextColor(tag)"
                            >
                                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                        </span>
                    </template>
                    
                    <div x-show="selectedTags.length === 0" class="text-gray-500 text-sm py-2">
                        No tags selected. Click tags from the categories to add them.
                    </div>
                </div>
                
                <!-- Tag strength legend -->
                <div class="mt-4 text-xs text-gray-400" x-show="selectedTags.length > 0">
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center">
                            <span class="w-3 h-3 bg-blue-600 rounded-full mr-1"></span>
                            <span>Normal</span>
                        </div>
                        <div class="flex items-center">
                            <span class="w-3 h-3 bg-green-600 rounded-full mr-1"></span>
                            <span>Emphasized ()</span>
                        </div>
                        <div class="text-gray-500">Click tag text to toggle emphasis, X to remove</div>
                    </div>
                </div>
            </div>

            <!-- Negative Tags Section -->
            <div class="bg-gray-800 border-b border-gray-700 p-6" x-show="selectedNegatives.length > 0 && selectedFile !== 'tutorial'">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold text-orange-300">Negative Tags</h2>
                    <button 
                        @click="clearAllNegatives()"
                        class="text-sm text-red-400 hover:text-orange-300 transition-colors"
                    >
                        Clear All
                    </button>
                </div>
                
                <div class="flex flex-wrap gap-2">
                    <template x-for="(tag, index) in selectedNegatives" :key="`negative-${index}-${tag.display || tag}`">
                        <span 
                            class="inline-flex items-center text-sm text-white rounded transition-colors"
                            :class="getSelectedTagClass(tag)"
                        >
                            <span 
                                class="px-3 py-1"
                                x-text="tag.display || tag"
                            ></span>
                            <button 
                                @click="removeTag(tag)"
                                class="pr-3 py-1"
                                :class="getButtonTextColor(tag)"
                            >
                                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                        </span>
                    </template>
                </div>
            </div>

        </div>
    </div>

    <script>
        function promptGenerator() {
            return {
                categories: [],
                allTags: [], // Track all tags in original order
                selectedTags: [],
                selectedPrefixes: [],
                selectedNegatives: [], // Track negative tags
                tagStrengths: {}, // Track tag strength levels (0=normal, 1=emphasized)
                openCategories: [],
                copyFeedback: false,
                negativeCopyFeedback: false,
                selectedFile: 'prompt-data.txt', // Default file
                availableFiles: [], // Will be populated by file discovery
                showInfoPanel: false,
                fileToReplace: null, // Track which file to replace when refreshing

                async init() {
                    // Load persisted state before loading files
                    this.loadPersistedState();
                    
                    // Load GitHub-hosted files and sample data
                    await this.discoverAvailableFiles();
                    // Start with all categories closed
                    this.openCategories = [];
                    
                    // Setup auto-save watchers
                    this.setupPersistence();
                },

                async discoverAvailableFiles() {
                    console.log('Starting file discovery...');
                    // GitHub repository configuration
                    const githubConfig = {
                        owner: 'Quick-Vendz',             // Your GitHub username
                        repo: 'promptr',                  // Your repository name
                        branch: 'main',                   // Your branch name
                        files: [
                            { file: 'tags/tag_types_example.txt', name: '- tag type examples' }
                        ]
                    };

                    // Preserve any local files that were restored from persistence, but reset built-in files
                    const preservedLocalFiles = this.availableFiles.filter(f => f.isLocal && !f.isBuiltIn);
                    
                    this.availableFiles = [
                        { file: 'tutorial', name: 'Help & Guide', isLocal: false, isBuiltIn: true, content: null },
                        ...preservedLocalFiles
                    ];

                    console.log('Trying to load files:', githubConfig.files);

                    // Try to load files from GitHub and other sources
                    for (const fileInfo of githubConfig.files) {
                        try {
                            let fileUrl;
                            let isGithub = true;
                            
                            // Check if it's already a full URL (like Catbox)
                            if (fileInfo.file.startsWith('http://') || fileInfo.file.startsWith('https://')) {
                                fileUrl = fileInfo.file;
                                isGithub = false;
                            } else {
                                // Try GitHub URL first for relative paths
                                fileUrl = `https://raw.githubusercontent.com/${githubConfig.owner}/${githubConfig.repo}/${githubConfig.branch}/${fileInfo.file}`;
                            }
                            
                            let response = await fetch(fileUrl);
                            
                            // If GitHub fails, try loading from local server
                            if (!response.ok && isGithub) {
                                console.log(`GitHub load failed for ${fileInfo.file} (${response.status}), trying local server...`);
                                fileUrl = `/${fileInfo.file}`;
                                response = await fetch(fileUrl);
                                isGithub = false;
                                console.log(`Local server response for ${fileInfo.file}:`, response.status);
                            }
                            
                            // Security: Validate response and content type
                            if (response.ok) {
                                console.log(`Successfully loaded ${fileInfo.file} from ${isGithub ? 'GitHub' : 'local server'}`);
                                const contentType = response.headers.get('content-type') || '';
                                if (!contentType.includes('text/plain') && !contentType.includes('text/csv') && !contentType.includes('application/octet-stream')) {
                                    console.log(`Skipping ${fileInfo.file}: Invalid content type (${contentType})`);
                                    continue;
                                }

                                // Security: Check response size before reading
                                const contentLength = response.headers.get('content-length');
                                if (contentLength && parseInt(contentLength) > 1024 * 1024) {
                                    console.log(`Skipping ${fileInfo.file}: File too large (${contentLength} bytes)`);
                                    continue;
                                }

                                this.availableFiles.push({
                                    file: fileInfo.file,
                                    name: fileInfo.name,
                                    url: fileUrl,
                                    isGithub: isGithub,
                                    isLocal: !isGithub && !fileInfo.file.startsWith('http'),
                                    isCatbox: fileInfo.file.includes('catbox.moe')
                                });
                                console.log(`Added file to dropdown: ${fileInfo.name}`);
                            } else {
                                console.log(`Failed to load ${fileInfo.file}: HTTP ${response.status}`);
                            }
                        } catch (error) {
                            console.log(`Could not load ${fileInfo.file}:`, error);
                        }
                    }

                    console.log('File discovery complete. Available files:', this.availableFiles.map(f => f.name));
                    
                    // Set the first available file as selected
                    this.selectedFile = this.availableFiles[0].file;
                    
                    // Load initial data
                    if (this.selectedFile === 'tutorial') {
                        this.loadTutorial();
                    } else {
                        await this.loadCategories();
                    }
                },

                async loadSelectedFile() {
                    // Note: We now preserve selections across file switches
                    // Users can manually clear if they want to start fresh
                    
                    // Load data for the selected file
                    if (this.selectedFile === 'tutorial') {
                        this.loadTutorial();
                    } else {
                        // Use the same loading logic as initial load
                        await this.loadCategories();
                    }
                    
                    // Start with all categories closed
                    this.openCategories = [];
                },

                async loadCustomFile(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        // Security: Validate file size (1MB limit)
                        if (file.size > 1024 * 1024) {
                            alert('File too large. Maximum size is 1MB.');
                            return;
                        }

                        // Security: Validate file type
                        if (!file.name.match(/\.(txt|csv)$/i)) {
                            alert('Invalid file type. Only .txt and .csv files are allowed.');
                            return;
                        }

                        const text = await file.text();
                        
                        // Security: Validate content size (100KB text limit)
                        if (text.length > 100000) {
                            alert('File content too large. Maximum content size is 100KB.');
                            return;
                        }

                        // Security: Basic content validation - check for suspicious patterns
                        if (text.includes('<script') || text.includes('javascript:') || text.includes('data:text/html')) {
                            alert('File contains potentially unsafe content.');
                            return;
                        }
                        
                        // Extract file info
                        const fileName = file.name;
                        const displayName = fileName.replace(/\.(txt|csv)$/i, '').replace(/[-_]/g, ' ');
                        
                        // Handle file replacement or addition
                        let targetFileName = fileName;
                        let targetDisplayName = displayName;
                        
                        // If we're replacing a file, validate filename matches
                        if (this.fileToReplace) {
                            const fileToReplaceInfo = this.availableFiles.find(f => f.file === this.fileToReplace);
                            if (fileToReplaceInfo) {
                                // Check if the selected file has the same name as the file being replaced
                                if (fileName !== this.fileToReplace) {
                                    alert(`Filename mismatch! You selected "${fileName}" but are trying to refresh "${this.fileToReplace}". Please select the same filename to refresh, or use Browse to add a new file.`);
                                    this.fileToReplace = null;
                                    event.target.value = '';
                                    return;
                                }
                                targetFileName = this.fileToReplace;
                                targetDisplayName = fileToReplaceInfo.name;
                            }
                        }
                        
                        const existingIndex = this.availableFiles.findIndex(f => f.file === targetFileName);
                        if (existingIndex === -1) {
                            this.availableFiles.push({ 
                                file: targetFileName, 
                                name: targetDisplayName,
                                content: text,
                                isLocal: true 
                            });
                        } else {
                            // Update existing entry with new content
                            this.availableFiles[existingIndex].content = text;
                            this.availableFiles[existingIndex].name = targetDisplayName;
                        }

                        // Switch to this file
                        this.selectedFile = targetFileName;
                        
                        // Clear the replacement flag
                        this.fileToReplace = null;
                        
                        // Clear existing selections
                        this.selectedTags = [];
                        this.selectedPrefixes = [];
                        this.selectedNegatives = [];
                        this.tagStrengths = {};
                        
                        // Parse the file content
                        this.parseCategories(text);
                        this.openCategories = [];
                        
                        // Clear the file input for security
                        event.target.value = '';

                    } catch (error) {
                        console.error('Error loading custom file:', error);
                        alert('Error loading file. Please make sure it\'s a valid text file.');
                        // Security: Clear the file input on error
                        event.target.value = '';
                        // Clear replacement flag on error
                        this.fileToReplace = null;
                    }
                },

                async loadCategories() {
                    try {
                        let text;
                        
                        if (this.selectedFile === 'tutorial') {
                            this.loadTutorial();
                            return;
                        }

                        // Check if this is a locally loaded file
                        const localFile = this.availableFiles.find(f => f.file === this.selectedFile && f.isLocal);
                        
                        if (localFile && localFile.content) {
                            // Use cached content from locally loaded file
                            text = localFile.content;
                        } else {
                            // Check if this is a GitHub file
                            const githubFile = this.availableFiles.find(f => f.file === this.selectedFile && f.isGithub);
                            
                            if (githubFile && githubFile.url) {
                                // Fetch from GitHub
                                const response = await fetch(githubFile.url);
                                if (!response.ok) throw new Error('File not found on GitHub');
                                
                                // Security: Validate content type and size
                                const contentType = response.headers.get('content-type') || '';
                                const contentLength = response.headers.get('content-length');
                                
                                if (!contentType.includes('text/plain') && !contentType.includes('text/csv') && !contentType.includes('application/octet-stream')) {
                                    throw new Error('Invalid content type from GitHub');
                                }
                                
                                if (contentLength && parseInt(contentLength) > 1024 * 1024) {
                                    throw new Error('File too large from GitHub');
                                }
                                
                                text = await response.text();
                                
                                // Security: Validate fetched content
                                if (text.length > 100000) {
                                    throw new Error('Content too large from GitHub');
                                }
                                
                                if (text.includes('<script') || text.includes('javascript:') || text.includes('data:text/html')) {
                                    throw new Error('Content contains potentially unsafe data from GitHub');
                                }
                            } else {
                                throw new Error('File source not found');
                            }
                        }
                        
                        this.parseCategories(text);
                    } catch (error) {
                        console.error('Error loading categories from ' + this.selectedFile + ':', error);
                        // Fallback to tutorial if file doesn't exist
                        this.loadTutorial();
                    }
                },

                parseCategories(text) {
                    const lines = text.split('\n').filter(line => line.trim());
                    const categories = [];
                    const allTags = [];
                    let currentCategory = null;
                    
                    // Skip duplicate checking for example tags file (tutorial purposes)
                    const isExampleFile = this.selectedFile === 'tags/tag_types_example.txt';
                    
                    // Track tags to detect duplicates within same purpose (positive vs negative)
                    const positiveTagValues = new Set(); // For normal and prefix tags
                    const negativeTagValues = new Set(); // For negative tags
                    const duplicates = [];

                    lines.forEach(line => {
                        if (line.startsWith('#')) {
                            // Category header
                            const categoryText = line.substring(1).trim();
                            const shouldSort = categoryText.includes('[a-z]');
                            const cleanName = categoryText.replace(/\[a-z\]/gi, '').trim();
                            
                            currentCategory = {
                                name: cleanName,
                                tags: [],
                                type: 'normal', // default type
                                sortAlphabetically: shouldSort
                            };
                            
                            // Check for special category types
                            const categoryName = currentCategory.name.toLowerCase();
                            if (categoryName.includes('prefix')) {
                                currentCategory.type = 'prefix';
                            } else if (categoryName.includes('negative')) {
                                currentCategory.type = 'negative';
                            }
                            // Default remains 'normal' for everything else
                            
                            categories.push(currentCategory);
                        } else if (currentCategory && line.trim()) {
                            // Tag - check if it has a display name format "Display Name|actual_prompt"
                            const tagLine = line.trim();
                            let tag;
                            
                            if (tagLine.includes('|')) {
                                const [displayName, actualPrompt] = tagLine.split('|');
                                tag = {
                                    display: displayName.trim(),
                                    value: actualPrompt.trim(),
                                    type: currentCategory.type,
                                    isMultiTag: true // Flag for visual differentiation
                                };
                            } else {
                                tag = {
                                    display: tagLine,
                                    value: tagLine,
                                    type: currentCategory.type,
                                    isMultiTag: false // Single tag
                                };
                            }
                            
                            // Check for duplicates within the same purpose (but skip for example file)
                            const tagValue = tag.value.toLowerCase();
                            if (!isExampleFile) {
                                if (currentCategory.type === 'negative') {
                                    if (negativeTagValues.has(tagValue)) {
                                        duplicates.push({
                                            tag: tag.value,
                                            category: currentCategory.name,
                                            type: 'negative'
                                        });
                                    } else {
                                        negativeTagValues.add(tagValue);
                                    }
                                } else {
                                    // Normal and prefix tags are both "positive" purpose
                                    if (positiveTagValues.has(tagValue)) {
                                        duplicates.push({
                                            tag: tag.value,
                                            category: currentCategory.name,
                                            type: currentCategory.type
                                        });
                                    } else {
                                        positiveTagValues.add(tagValue);
                                    }
                                }
                            }
                            
                            currentCategory.tags.push(tag);
                            if (currentCategory.type === 'normal') {
                                allTags.push(tag);
                            }
                        }
                    });

                    // Show warning if duplicates found (but not for example file)
                    if (!isExampleFile && duplicates.length > 0) {
                        const duplicateList = duplicates.map(d => `"${d.tag}" in "${d.category}" (${d.type})`).join('\n');
                        alert(`⚠️ Duplicate tags detected!\n\nThe same tag appears multiple times within the same purpose:\n\n${duplicateList}\n\nNote: Tags can appear in both positive AND negative categories, but shouldn't be duplicated within the same purpose (positive or negative) as this will cause logic issues.`);
                    }

                    // Sort tags alphabetically only for categories with [a-z] keyword
                    categories.forEach(category => {
                        if (category.sortAlphabetically) {
                            category.tags.sort((a, b) => {
                                const displayA = (a.display || a).toLowerCase();
                                const displayB = (b.display || b).toLowerCase();
                                return displayA.localeCompare(displayB);
                            });
                        }
                        // Categories without [a-z] keep their original order from the file
                    });

                    this.categories = categories;
                    this.allTags = allTags;
                },

                loadTutorial() {
                    // Clear categories for tutorial mode
                    this.categories = [];
                    this.allTags = [];
                },

                showTutorialInfo() {
                    // Show the tutorial info panel
                    this.showInfoPanel = true;
                },

                toggleCategory(categoryName) {
                    // Allow multiple categories to be open - simple toggle
                    if (this.openCategories.includes(categoryName)) {
                        this.openCategories = this.openCategories.filter(name => name !== categoryName);
                    } else {
                        this.openCategories.push(categoryName);
                    }
                },

                addRemoveTag(tag) {
                    const tagKey = tag.value || tag;
                    
                    if (tag.type === 'prefix') {
                        this.togglePrefixTag(tag);
                    } else if (tag.type === 'negative') {
                        this.toggleNegativeTag(tag);
                    } else {
                        // Normal tags - simple add/remove only for left panel
                        if (this.selectedTags.find(t => (t.value || t) === tagKey)) {
                            // Remove tag
                            this.selectedTags = this.selectedTags.filter(t => (t.value || t) !== tagKey);
                            delete this.tagStrengths[tagKey];
                        } else {
                            // Add tag normally
                            const newSelectedTags = [...this.selectedTags, tag];
                            this.selectedTags = this.allTags.filter(t => newSelectedTags.find(st => (st.value || st) === (t.value || t)));
                            this.tagStrengths[tagKey] = 0;
                        }
                    }
                },

                toggleTagStrength(tag) {
                    // This function is for right-panel tags only - cycles through strength levels
                    const tagKey = tag.value || tag;
                    const currentStrength = this.tagStrengths[tagKey] || 0;
                    
                    if (currentStrength === 0) {
                        // Emphasize tag
                        this.tagStrengths[tagKey] = 1;
                    } else {
                        // Back to normal
                        this.tagStrengths[tagKey] = 0;
                    }
                },

                removeTag(tag) {
                    const tagKey = tag.value || tag;
                    
                    if (tag.type === 'prefix') {
                        this.selectedPrefixes = this.selectedPrefixes.filter(t => (t.value || t) !== tagKey);
                    } else if (tag.type === 'negative') {
                        this.selectedNegatives = this.selectedNegatives.filter(t => (t.value || t) !== tagKey);
                    } else {
                        this.selectedTags = this.selectedTags.filter(t => (t.value || t) !== tagKey);
                        delete this.tagStrengths[tagKey];
                    }
                },

                togglePrefixTag(tag) {
                    const tagKey = tag.value || tag;
                    if (this.selectedPrefixes.find(t => (t.value || t) === tagKey)) {
                        this.selectedPrefixes = this.selectedPrefixes.filter(t => (t.value || t) !== tagKey);
                    } else {
                        this.selectedPrefixes.push(tag);
                    }
                },

                toggleNegativeTag(tag) {
                    const tagKey = tag.value || tag;
                    if (this.selectedNegatives.find(t => (t.value || t) === tagKey)) {
                        this.selectedNegatives = this.selectedNegatives.filter(t => (t.value || t) !== tagKey);
                    } else {
                        this.selectedNegatives.push(tag);
                    }
                },

                clearAllTags() {
                    this.selectedTags = [];
                    this.tagStrengths = {};
                },

                clearAllPrefixes() {
                    this.selectedPrefixes = [];
                },

                clearAllNegatives() {
                    this.selectedNegatives = [];
                },

                clearAllSelections() {
                    this.selectedTags = [];
                    this.selectedPrefixes = [];
                    this.selectedNegatives = [];
                    this.tagStrengths = {};
                    // Note: We don't clear persisted state here, just current selections
                    // The state will be auto-saved due to the watchers
                },

                clearPromptTags() {
                    this.selectedTags = [];
                    this.selectedPrefixes = [];
                    this.tagStrengths = {};
                    // Note: We don't clear persisted state here, just current selections
                    // The state will be auto-saved due to the watchers
                },

                getTagClass(tag) {
                    const tagKey = tag.value || tag;
                    const isMultiTag = tag.isMultiTag;
                    const borderStyle = isMultiTag ? 'border-2 border-dashed' : 'border';
                    
                    // Tutorial mode - different styles for different types
                    if (tag.type === 'info') {
                        return `bg-blue-700 text-blue-100 border-blue-500 cursor-default ${borderStyle}`;
                    } else if (tag.type === 'link') {
                        return `bg-green-700 text-green-100 border-green-500 hover:bg-green-600 cursor-pointer ${borderStyle}`;
                    } else if (tag.type === 'tip') {
                        return `bg-yellow-700 text-yellow-100 border-yellow-500 cursor-default ${borderStyle}`;
                    } else if (tag.type === 'tech') {
                        return `bg-gray-600 text-gray-100 border-gray-400 cursor-default ${borderStyle}`;
                    } else if (tag.type === 'prefix') {
                        const isSelected = this.selectedPrefixes.find(t => (t.value || t) === tagKey);
                        if (isSelected) {
                            const borderColor = isMultiTag ? 'border-purple-300' : 'border-purple-600';
                            return `bg-purple-600 text-white ${borderColor} ${borderStyle}`;
                        } else {
                            return `bg-gray-700 text-purple-300 border-purple-500 hover:border-purple-400 hover:bg-gray-600 ${borderStyle}`;
                        }
                    } else if (tag.type === 'negative') {
                        const isSelected = this.selectedNegatives.find(t => (t.value || t) === tagKey);
                        if (isSelected) {
                            const borderColor = isMultiTag ? 'border-orange-300' : 'border-orange-600';
                            return `bg-orange-600 text-white ${borderColor} ${borderStyle}`;
                        } else {
                            return `bg-gray-700 text-orange-300 border-orange-500 hover:border-orange-400 hover:bg-gray-600 ${borderStyle}`;
                        }
                    } else {
                        const isSelected = this.selectedTags.find(t => (t.value || t) === tagKey);
                        const strength = this.tagStrengths[tagKey] || 0;
                        
                        if (!isSelected) {
                            return `bg-gray-700 text-gray-300 border-gray-500 hover:border-blue-400 hover:bg-gray-600 ${borderStyle}`;
                        } else if (strength === 1) {
                            const borderColor = isMultiTag ? 'border-green-300' : 'border-green-600';
                            return `bg-green-600 text-white ${borderColor} ${borderStyle}`; // Emphasized
                        } else {
                            const borderColor = isMultiTag ? 'border-blue-300' : 'border-blue-600';
                            return `bg-blue-600 text-white ${borderColor} ${borderStyle}`; // Normal selected
                        }
                    }
                },

                getSelectedTagClass(tag) {
                    const tagKey = tag.value || tag;
                    const strength = this.tagStrengths[tagKey] || 0;
                    const isMultiTag = tag.isMultiTag;
                    const borderStyle = isMultiTag ? 'border-2 border-dashed' : 'border';
                    
                    if (tag.type === 'prefix') {
                        const borderColor = isMultiTag ? 'border-purple-300' : 'border-purple-600';
                        return `bg-purple-600 text-white ${borderColor} ${borderStyle}`;
                    } else if (tag.type === 'negative') {
                        const borderColor = isMultiTag ? 'border-orange-300' : 'border-orange-600';
                        return `bg-orange-600 text-white ${borderColor} ${borderStyle}`;
                    } else if (strength === 1) {
                        const borderColor = isMultiTag ? 'border-green-300' : 'border-green-600';
                        return `bg-green-600 text-white ${borderColor} ${borderStyle}`; // Emphasized
                    } else {
                        const borderColor = isMultiTag ? 'border-blue-300' : 'border-blue-600';
                        return `bg-blue-600 text-white ${borderColor} ${borderStyle}`; // Normal
                    }
                },

                getButtonTextColor(tag) {
                    const tagKey = tag.value || tag;
                    const strength = this.tagStrengths[tagKey] || 0;
                    
                    if (tag.type === 'prefix') {
                        return 'text-purple-200 hover:text-white';
                    } else if (tag.type === 'negative') {
                        return 'text-orange-200 hover:text-white';
                    } else if (strength === 1) {
                        return 'text-green-200 hover:text-white'; // Emphasized
                    } else {
                        return 'text-blue-200 hover:text-white'; // Normal
                    }
                },

                getCategoryCount(category) {
                    if (category.type === 'prefix') {
                        return this.selectedPrefixes.filter(selected => 
                            category.tags.some(tag => (tag.value || tag) === (selected.value || selected))
                        ).length;
                    } else if (category.type === 'negative') {
                        return this.selectedNegatives.filter(selected => 
                            category.tags.some(tag => (tag.value || tag) === (selected.value || selected))
                        ).length;
                    } else {
                        return this.selectedTags.filter(selected => 
                            category.tags.some(tag => (tag.value || tag) === (selected.value || selected))
                        ).length;
                    }
                },

                generatePrompt() {
                    const parts = [];
                    
                    // Add prefixes first
                    if (this.selectedPrefixes.length > 0) {
                        parts.push(...this.selectedPrefixes.map(tag => tag.value || tag));
                    }
                    
                    // Add normal tags with strength modifiers
                    if (this.selectedTags.length > 0) {
                        const tagParts = this.selectedTags.map(tag => {
                            const tagKey = tag.value || tag;
                            const strength = this.tagStrengths[tagKey] || 0;
                            const value = tag.value || tag;
                            return strength === 1 ? `(${value})` : value;
                        });
                        parts.push(...tagParts);
                    }
                    
                    return parts.join(', ');
                },

                generatePromptHTML() {
                    const parts = [];
                    
                    // Add prefixes first (in purple)
                    if (this.selectedPrefixes.length > 0) {
                        const prefixParts = this.selectedPrefixes.map(tag => 
                            `<span class="text-purple-400">${tag.value || tag}</span>`
                        );
                        parts.push(...prefixParts);
                    }
                    
                    // Add normal tags with strength modifiers (in normal color)
                    if (this.selectedTags.length > 0) {
                        const tagParts = this.selectedTags.map(tag => {
                            const tagKey = tag.value || tag;
                            const strength = this.tagStrengths[tagKey] || 0;
                            const value = tag.value || tag;
                            const displayValue = strength === 1 ? `(${value})` : value;
                            return `<span class="text-gray-200">${displayValue}</span>`;
                        });
                        parts.push(...tagParts);
                    }
                    
                    // Ensure proper spacing: comma + space between tags
                    return parts.join(', ');
                },

                generateNegativePrompt() {
                    const negatives = [];
                    
                    // Add negative tags
                    this.selectedNegatives.forEach(tag => {
                        negatives.push(tag.value || tag);
                    });
                    
                    if (negatives.length === 0) return '';
                    // Ensure proper spacing: comma + space between tags
                    return negatives.join(', ');
                },

                async copyPrompt() {
                    const prompt = this.generatePrompt();
                    if (prompt) {
                        try {
                            await navigator.clipboard.writeText(prompt);
                            this.showCopyFeedback();
                        } catch (error) {
                            console.error('Error copying to clipboard:', error);
                        }
                    }
                },

                async copyNegativePrompt() {
                    const prompt = this.generateNegativePrompt();
                    if (prompt) {
                        try {
                            await navigator.clipboard.writeText(prompt);
                            this.showNegativeCopyFeedback();
                        } catch (error) {
                            console.error('Error copying negative prompt to clipboard:', error);
                        }
                    }
                },

                showCopyFeedback() {
                    this.copyFeedback = true;
                    setTimeout(() => {
                        this.copyFeedback = false;
                    }, 2000);
                },

                showNegativeCopyFeedback() {
                    this.negativeCopyFeedback = true;
                    setTimeout(() => {
                        this.negativeCopyFeedback = false;
                    }, 2000);
                },

                // Persistence methods for localStorage
                loadPersistedState() {
                    try {
                        const saved = localStorage.getItem('promptGenerator_state');
                        if (saved) {
                            const state = JSON.parse(saved);
                            this.selectedTags = state.selectedTags || [];
                            this.selectedPrefixes = state.selectedPrefixes || [];
                            this.selectedNegatives = state.selectedNegatives || [];
                            this.tagStrengths = state.tagStrengths || {};
                            this.selectedFile = state.selectedFile || 'tutorial';
                            
                            // Restore local files if they exist
                            if (state.localFiles && Array.isArray(state.localFiles)) {
                                // Add local files back to availableFiles
                                state.localFiles.forEach(localFile => {
                                    const existingIndex = this.availableFiles.findIndex(f => f.file === localFile.file);
                                    if (existingIndex === -1) {
                                        this.availableFiles.push(localFile);
                                    }
                                });
                            }
                            
                            console.log('Loaded persisted state:', state);
                        }
                    } catch (error) {
                        console.log('Error loading persisted state:', error);
                    }
                },

                saveState() {
                    try {
                        // Extract only local files to save (exclude built-in files)
                        const localFiles = this.availableFiles.filter(f => f.isLocal && !f.isBuiltIn);
                        
                        const state = {
                            selectedTags: this.selectedTags,
                            selectedPrefixes: this.selectedPrefixes,
                            selectedNegatives: this.selectedNegatives,
                            tagStrengths: this.tagStrengths,
                            selectedFile: this.selectedFile,
                            localFiles: localFiles, // Save local files
                            timestamp: Date.now()
                        };
                        localStorage.setItem('promptGenerator_state', JSON.stringify(state));
                        console.log('Saved state to localStorage');
                    } catch (error) {
                        console.log('Error saving state:', error);
                    }
                },

                setupPersistence() {
                    // Auto-save whenever tags change
                    this.$watch('selectedTags', () => this.saveState());
                    this.$watch('selectedPrefixes', () => this.saveState());
                    this.$watch('selectedNegatives', () => this.saveState());
                    this.$watch('tagStrengths', () => this.saveState());
                    this.$watch('availableFiles', () => this.saveState()); // Save when files are added
                    this.$watch('selectedFile', () => {
                        this.saveState();
                        // Close info panel when switching away from tutorial
                        if (this.selectedFile !== 'tutorial') {
                            this.showInfoPanel = false;
                        }
                    });
                },

                clearPersistedState() {
                    try {
                        localStorage.removeItem('promptGenerator_state');
                        
                        // Also remove local files from availableFiles
                        this.availableFiles = this.availableFiles.filter(f => !f.isLocal);
                        
                        // Reset to tutorial if current selection was a local file
                        const currentFile = this.availableFiles.find(f => f.file === this.selectedFile);
                        if (!currentFile) {
                            this.selectedFile = 'tutorial';
                            this.loadTutorial();
                        }
                        
                        console.log('Cleared persisted state and local files');
                    } catch (error) {
                        console.log('Error clearing persisted state:', error);
                    }
                },

                removeLocalFile(fileName) {
                    // Remove from availableFiles
                    this.availableFiles = this.availableFiles.filter(f => f.file !== fileName);
                    
                    // Switch to tutorial if the removed file was selected
                    if (this.selectedFile === fileName) {
                        this.selectedFile = 'tutorial';
                        this.loadTutorial();
                    }
                },

                refreshLocalFile() {
                    // Store the current file name for replacement
                    this.fileToReplace = this.selectedFile;
                    // Trigger file input
                    this.$refs.fileInput.click();
                }
            }
        }
    </script>
</body>
</html>